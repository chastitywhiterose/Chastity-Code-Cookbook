     1                                  org 100h
     2                                  main:
     3                                  
     4 00000000 C706[5100]0A00          mov word [radix],10
     5 00000006 C706[5300]0100          mov word [int_width],1
     6                                  
     7 0000000C B80300                  mov ax,3
     8 0000000F BB0500                  mov bx,5
     9 00000012 01D8                    add ax,bx
    10                                  
    11 00000014 E87800                  call putint
    12                                  
    13 00000017 B400                    mov ah,0
    14 00000019 CD21                    int 21h
    15                                  
    16                                  %include 'chastelib16.asm'
     1                              <1> ; This file is where I keep my function definitions.
     2                              <1> ; These are usually my string and integer output routines.
     3                              <1> 
     4                              <1> ;this is my best putstring function for DOS because it uses call 40h of interrupt 21h
     5                              <1> ;this means that it works in a similar way to my Linux Assembly code
     6                              <1> ;the plan is to make both my DOS and Linux functions identical except for the size of registers involved
     7                              <1> 
     8 0000001B 0100                <1> stdout dw 1 ; variable for standard output so that it can theoretically be redirected
     9                              <1> 
    10                              <1> putstring:
    11                              <1> 
    12 0000001D 50                  <1> push ax
    13 0000001E 53                  <1> push bx
    14 0000001F 51                  <1> push cx
    15 00000020 52                  <1> push dx
    16                              <1> 
    17 00000021 89C3                <1> mov bx,ax                  ;copy ax to bx for use as index register
    18                              <1> 
    19                              <1> putstring_strlen_start:    ;this loop finds the length of the string as part of the putstring function
    20                              <1> 
    21 00000023 803F00              <1> cmp [bx], byte 0           ;compare this byte with 0
    22 00000026 7403                <1> jz putstring_strlen_end    ;if comparison was zero, jump to loop end because we have found the length
    23 00000028 43                  <1> inc bx                     ;increment bx (add 1)
    24 00000029 EBF8                <1> jmp putstring_strlen_start ;jump to the start of the loop and keep trying until we find a zero
    25                              <1> 
    26                              <1> putstring_strlen_end:
    27                              <1> 
    28 0000002B 29C3                <1> sub bx,ax                  ; sub ax from bx to get the difference for number of bytes
    29 0000002D 89D9                <1> mov cx,bx                  ; mov bx to cx
    30 0000002F 89C2                <1> mov dx,ax                  ; dx will have address of string to write
    31                              <1> 
    32 00000031 B440                <1> mov ah,40h                 ; select DOS function 40h write 
    33 00000033 8B1E[1B00]          <1> mov bx,[stdout]            ; file handle 1=stdout
    34 00000037 CD21                <1> int 21h                    ; call the DOS kernel
    35                              <1> 
    36 00000039 5A                  <1> pop dx
    37 0000003A 59                  <1> pop cx
    38 0000003B 5B                  <1> pop bx
    39 0000003C 58                  <1> pop ax
    40                              <1> 
    41 0000003D C3                  <1> ret
    42                              <1> 
    43                              <1> 
    44                              <1> 
    45                              <1> ;this is the location in memory where digits are written to by the intstr function
    46 0000003E 3F3F3F3F3F3F3F3F3F- <1> int_string db 16 dup '?' ;enough bytes to hold maximum size 16-bit binary integer
    46 00000047 3F3F3F3F3F3F3F      <1>
    47                              <1> ;this is the end of the integer string optional line feed and terminating zero
    48                              <1> ;clever use of this label can change the ending to be a different character when needed 
    49 0000004E 0D0A00              <1> int_newline db 0Dh,0Ah,0 ;the proper way to end a line in DOS/Windows
    50                              <1> 
    51 00000051 0200                <1> radix dw 2 ;radix or base for integer output. 2=binary, 8=octal, 10=decimal, 16=hexadecimal
    52 00000053 0800                <1> int_width dw 8
    53                              <1> 
    54                              <1> intstr:
    55                              <1> 
    56 00000055 BB[4D00]            <1> mov bx,int_newline-1 ;find address of lowest digit(just before the newline 0Ah)
    57 00000058 B90100              <1> mov cx,1
    58                              <1> 
    59                              <1> digits_start:
    60                              <1> 
    61 0000005B BA0000              <1> mov dx,0;
    62 0000005E F736[5100]          <1> div word [radix]
    63 00000062 83FA0A              <1> cmp dx,10
    64 00000065 7202                <1> jb decimal_digit
    65 00000067 7D05                <1> jge hexadecimal_digit
    66                              <1> 
    67                              <1> decimal_digit: ;we go here if it is only a digit 0 to 9
    68 00000069 83C230              <1> add dx,'0'
    69 0000006C EB06                <1> jmp save_digit
    70                              <1> 
    71                              <1> hexadecimal_digit:
    72 0000006E 83EA0A              <1> sub dx,10
    73 00000071 83C241              <1> add dx,'A'
    74                              <1> 
    75                              <1> save_digit:
    76                              <1> 
    77 00000074 8817                <1> mov [bx],dl
    78 00000076 83F800              <1> cmp ax,0
    79 00000079 7404                <1> jz intstr_end
    80 0000007B 4B                  <1> dec bx
    81 0000007C 41                  <1> inc cx
    82 0000007D EBDC                <1> jmp digits_start
    83                              <1> 
    84                              <1> intstr_end:
    85                              <1> 
    86                              <1> prefix_zeros:
    87 0000007F 3B0E[5300]          <1> cmp cx,[int_width]
    88 00000083 7307                <1> jnb end_zeros
    89 00000085 4B                  <1> dec bx
    90 00000086 C60730              <1> mov [bx],byte '0'
    91 00000089 41                  <1> inc cx
    92 0000008A EBF3                <1> jmp prefix_zeros
    93                              <1> end_zeros:
    94                              <1> 
    95 0000008C 89D8                <1> mov ax,bx ; store string in ax for display later
    96                              <1> 
    97 0000008E C3                  <1> ret
    98                              <1> 
    99                              <1> 
   100                              <1> 
   101                              <1> ;function to print string form of whatever integer is in eax
   102                              <1> ;The radix determines which number base the string form takes.
   103                              <1> ;Anything from 2 to 36 is a valid radix
   104                              <1> ;in practice though, only bases 2,8,10,and 16 will make sense to other programmers
   105                              <1> ;this function does not process anything by itself but calls the combination of my other
   106                              <1> ;functions in the order I intended them to be used.
   107                              <1> 
   108                              <1> putint: 
   109                              <1> 
   110 0000008F 50                  <1> push ax
   111 00000090 53                  <1> push bx
   112 00000091 51                  <1> push cx
   113 00000092 52                  <1> push dx
   114                              <1> 
   115 00000093 E8BFFF              <1> call intstr
   116 00000096 E884FF              <1> call putstring
   117                              <1> 
   118 00000099 5A                  <1> pop dx
   119 0000009A 59                  <1> pop cx
   120 0000009B 5B                  <1> pop bx
   121 0000009C 58                  <1> pop ax
   122                              <1> 
   123 0000009D C3                  <1> ret
   124                              <1> 
   125                              <1> 
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> 
   132                              <1> ;this function converts a string pointed to by ax into an integer returned in eax instead
   133                              <1> ;it is a little complicated because it has to account for whether the character in
   134                              <1> ;a string is a decimal digit 0 to 9, or an alphabet character for bases higher than ten
   135                              <1> ;it also checks for both uppercase and lowercase letters for bases 11 to 36
   136                              <1> ;finally, it checks if that letter makes sense for the base.
   137                              <1> ;For example, G to Z cannot be used in hexadecimal, only A to F can
   138                              <1> ;The purpose of writing this function was to be able to accept user input as integers
   139                              <1> 
   140                              <1> strint:
   141                              <1> 
   142 0000009E 89C3                <1> mov bx,ax ;copy string address from ax to bx because eax will be replaced soon!
   143 000000A0 B80000              <1> mov ax,0
   144                              <1> 
   145                              <1> read_strint:
   146 000000A3 B90000              <1> mov cx,0 ; zero ecx so only lower 8 bits are used
   147 000000A6 8A0F                <1> mov cl,[bx]
   148 000000A8 43                  <1> inc bx
   149 000000A9 80F900              <1> cmp cl,0 ; compare byte at address edx with 0
   150 000000AC 7446                <1> jz strint_end ; if comparison was zero, this is the end of string
   151                              <1> 
   152                              <1> ;if char is below '0' or above '9', it is outside the range of these and is not a digit
   153 000000AE 80F930              <1> cmp cl,'0'
   154 000000B1 720A                <1> jb not_digit
   155 000000B3 80F939              <1> cmp cl,'9'
   156 000000B6 7705                <1> ja not_digit
   157                              <1> 
   158                              <1> ;but if it is a digit, then correct and process the character
   159                              <1> is_digit:
   160 000000B8 80E930              <1> sub cl,'0'
   161 000000BB EB26                <1> jmp process_char
   162                              <1> 
   163                              <1> not_digit:
   164                              <1> ;it isn't a digit, but it could be perhaps and alphabet character
   165                              <1> ;which is a digit in a higher base
   166                              <1> 
   167                              <1> ;if char is below 'A' or above 'Z', it is outside the range of these and is not capital letter
   168 000000BD 80F941              <1> cmp cl,'A'
   169 000000C0 720D                <1> jb not_upper
   170 000000C2 80F95A              <1> cmp cl,'Z'
   171 000000C5 7708                <1> ja not_upper
   172                              <1> 
   173                              <1> is_upper:
   174 000000C7 80E941              <1> sub cl,'A'
   175 000000CA 80C10A              <1> add cl,10
   176 000000CD EB14                <1> jmp process_char
   177                              <1> 
   178                              <1> not_upper:
   179                              <1> 
   180                              <1> ;if char is below 'a' or above 'z', it is outside the range of these and is not lowercase letter
   181 000000CF 80F961              <1> cmp cl,'a'
   182 000000D2 720D                <1> jb not_lower
   183 000000D4 80F97A              <1> cmp cl,'z'
   184 000000D7 7708                <1> ja not_lower
   185                              <1> 
   186                              <1> is_lower:
   187 000000D9 80E961              <1> sub cl,'a'
   188 000000DC 80C10A              <1> add cl,10
   189 000000DF EB02                <1> jmp process_char
   190                              <1> 
   191                              <1> not_lower:
   192                              <1> 
   193                              <1> ;if we have reached this point, result invalid and end function
   194 000000E1 EB11                <1> jmp strint_end
   195                              <1> 
   196                              <1> process_char:
   197                              <1> 
   198 000000E3 3B0E[5100]          <1> cmp cx,[radix] ;compare char with radix
   199 000000E7 730B                <1> jae strint_end ;if this value is above or equal to radix, it is too high despite being a valid digit/alpha
   200                              <1> 
   201 000000E9 BA0000              <1> mov dx,0 ;zero edx because it is used in mul sometimes
   202 000000EC F726[5100]          <1> mul word [radix]    ;mul eax with radix
   203 000000F0 01C8                <1> add ax,cx
   204                              <1> 
   205 000000F2 EBAF                <1> jmp read_strint ;jump back and continue the loop if nothing has exited it
   206                              <1> 
   207                              <1> strint_end:
   208                              <1> 
   209 000000F4 C3                  <1> ret
   210                              <1> 
   211                              <1> ;returns in al register a character from the keyboard
   212                              <1> getchr:
   213                              <1> 
   214 000000F5 B401                <1> mov ah,1
   215 000000F7 CD21                <1> int 21h
   216                              <1> 
   217 000000F9 C3                  <1> ret
   218                              <1> 
   219                              <1> ;the next utility functions simply print a space or a newline
   220                              <1> ;these help me save code when printing lots of things for debugging
   221                              <1> 
   222 000000FA 2000                <1> space db ' ',0
   223 000000FC 0D0A00              <1> line db 0Dh,0Ah,0
   224                              <1> 
   225                              <1> putspace:
   226 000000FF 50                  <1> push ax
   227 00000100 B8[FA00]            <1> mov ax,space
   228 00000103 E817FF              <1> call putstring
   229 00000106 58                  <1> pop ax
   230 00000107 C3                  <1> ret
   231                              <1> 
   232                              <1> putline:
   233 00000108 50                  <1> push ax
   234 00000109 B8[FC00]            <1> mov ax,line
   235 0000010C E80EFF              <1> call putstring
   236 0000010F 58                  <1> pop ax
   237 00000110 C3                  <1> ret
